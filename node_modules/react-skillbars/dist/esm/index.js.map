{"version":3,"file":"index.js","sources":["../../src/util/index.ts","../../../../node_modules/style-inject/dist/style-inject.es.js","../../src/util/hooks/useIsServer.tsx","../../src/components/skillbar.tsx","../../src/util/hooks/useIntersection.tsx"],"sourcesContent":["export class Utils {\n  public static isString = (value: unknown) =>\n    Object.prototype.toString.call(value) === '[object String]';\n\n  public static isNumber = (value: unknown) =>\n    Object.prototype.toString.call(value) === '[object Number]';\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  public static getHSL = (container: any, index: number, length: number) => {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const calculateStep = function calculateStep(value: number | any) {\n      if (Utils.isNumber(value)) {\n        return value;\n      }\n      return value.minimum + (index * (value.maximum - value.minimum)) / length;\n    };\n\n    const hue = calculateStep(container.hue);\n    const sat = calculateStep(container.saturation);\n    const level = calculateStep(container.level);\n\n    return `hsl(${hue}, ${sat}%, ${level}%)`;\n  };\n\n  public static getHeight = (propHeight: number | string) =>\n    Utils.isString(propHeight) ? propHeight : `${propHeight}px`;\n}\n","function styleInject(css, ref) {\n  if ( ref === void 0 ) ref = {};\n  var insertAt = ref.insertAt;\n\n  if (!css || typeof document === 'undefined') { return; }\n\n  var head = document.head || document.getElementsByTagName('head')[0];\n  var style = document.createElement('style');\n  style.type = 'text/css';\n\n  if (insertAt === 'top') {\n    if (head.firstChild) {\n      head.insertBefore(style, head.firstChild);\n    } else {\n      head.appendChild(style);\n    }\n  } else {\n    head.appendChild(style);\n  }\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nexport default styleInject;\n","import { useEffect, useState } from 'react';\n\n/**\n * As `useEffect` is only called on the client, this will execute and set state to false only on client\n */\nexport const useIsServer = () => {\n  const [isServer, setIsServer] = useState(true);\n  useEffect(() => {\n    setIsServer(false);\n  }, []);\n  return isServer;\n};\n","import React, { FC, useCallback, useEffect, useRef, useState } from 'react';\nimport { Utils } from '../util';\nimport { useIntersection } from '../util/hooks/useIntersection';\nimport { SkillBarProps, SkillBarSkill } from './index';\nimport './skillbar.css';\nimport { useIsServer } from '../util/hooks/useIsServer';\n\nconst SkillBar: FC<SkillBarProps> = ({\n  skills,\n  colors,\n  barBackground = 'transparent',\n  offset = `25px`,\n  height = 35,\n  symbol = '%',\n  symbolColor = 'white',\n  animationDuration = 3000,\n  animationDelay = 1000,\n  animationThreshold = 0.8,\n}) => {\n  let intersection: IntersectionObserverEntry | null = null;\n  const ref = useRef<HTMLDivElement | null>(null);\n\n  const [isCollapsed, setIsCollapsed] = useState(true);\n\n  const isServer = useIsServer();\n\n  intersection = useIntersection(\n    ref,\n    {\n      root: null,\n      rootMargin: offset,\n      threshold: animationThreshold,\n    },\n    isServer\n  );\n\n  /**\n   * Based on IntersectionObserver API response, it sets with configurable timeout the animation trigger to show the bar\n   */\n  useEffect(() => {\n    if (intersection && intersection.isIntersecting) {\n      const timer = setTimeout(() => setIsCollapsed(false), animationDelay);\n      return () => clearTimeout(timer);\n    }\n  }, [intersection]);\n\n  /**\n   * Computes based on individual or global `colors` object the coloring of the bar\n   */\n  const getSkillBarColor = useCallback(\n    (skill: SkillBarSkill, index: number) => {\n      if (skill.color && skill.color.bar && Utils.isString(skill.color.bar)) {\n        return skill.color.bar;\n      } else if (colors && colors.bar) {\n        if (Utils.isString(colors.bar)) {\n          return colors.bar;\n        }\n        return Utils.getHSL(colors.bar, index, skills.length);\n      }\n      return '';\n    },\n    []\n  );\n\n  /**\n   * Computes based on individual or global `colors` object the coloring of the text\n   */\n  const getTitleColor = useCallback(\n    (skill: SkillBarSkill, index: number, entry: string) => {\n      if (\n        skill.color &&\n        skill.color.title &&\n        skill.color.title[entry] &&\n        Utils.isString(skill.color.title[entry])\n      ) {\n        return skill.color.title[entry];\n      } else if (colors && colors.title && colors.title[entry]) {\n        if (Utils.isString(colors.title[entry])) {\n          return colors.title[entry];\n        }\n        return Utils.getHSL(colors.title[entry], index, skills.length);\n      }\n      return '';\n    },\n    []\n  );\n\n  return (\n    <div data-testid={'skillbar/root'} ref={ref}>\n      {skills.map((skill, index) => (\n        <div\n          key={skill.type}\n          className=\"skillbar\"\n          data-testid={'skillbar/container'}\n          style={{\n            height: `${Utils.getHeight(height)}`,\n            lineHeight: `${Utils.getHeight(height)}`,\n            background: barBackground,\n          }}\n        >\n          <div\n            className=\"skillbar-title\"\n            data-testid={'skillbar/title'}\n            style={{\n              color: `${getTitleColor(skill, index, 'text')}`,\n              background: `${getTitleColor(skill, index, 'background')}`,\n            }}\n          >\n            <span>{skill.type}</span>\n          </div>\n          <div\n            data-testid={'skillbar/bar'}\n            className={`skillbar-bar ${isCollapsed ? 'collapsed' : ''}`}\n            style={{\n              background: `${getSkillBarColor(skill, index)}`,\n              width: `calc((100% - 110px) * (${skill.level} * 0.01))`,\n              transition: `width ${animationDuration}ms ease-in-out`,\n            }}\n          />\n          <div className=\"skillbar-percent\" data-testid={'skillbar/percent'}\n            style={{\n              color: symbolColor\n            }}>\n            {skill.level}\n            {symbol}\n          </div>\n        </div>\n      ))}\n    </div>\n  );\n};\n\nexport default SkillBar;\n","import { RefObject, useEffect, useState } from 'react';\n\n/**\n * Hook used for checking whether provided component is in viewport or not based on configured thresholds\n * @param ref\n * @param options\n * @param isServer\n */\nexport const useIntersection = (\n  ref: RefObject<HTMLElement>,\n  options: IntersectionObserverInit,\n  isServer: boolean\n): IntersectionObserverEntry | null => {\n  const [intersectionObserverEntry, setIntersectionObserverEntry] =\n    useState<IntersectionObserverEntry | null>(null);\n\n  useEffect(() => {\n    if (\n      !isServer &&\n      ref.current &&\n      typeof IntersectionObserver === 'function'\n    ) {\n      const handler = (entries: IntersectionObserverEntry[]) => {\n        setIntersectionObserverEntry(entries[0]);\n      };\n\n      const observer = new IntersectionObserver(handler, options);\n      observer.observe(ref.current);\n\n      return () => {\n        setIntersectionObserverEntry(null);\n        observer.disconnect();\n      };\n    }\n    return () => {\n      return;\n    };\n  }, [ref.current, options.threshold, options.root, options.rootMargin]);\n\n  return intersectionObserverEntry;\n};\n"],"names":["Utils","isString","value","Object","prototype","toString","call","isNumber","getHSL","container","index","length","calculateStep","minimum","maximum","hue","sat","saturation","level","concat","getHeight","propHeight","css","ref","insertAt","document","head","getElementsByTagName","style","createElement","type","firstChild","insertBefore","appendChild","styleSheet","cssText","createTextNode","SkillBar","_a","intersection","skills","colors","_b","barBackground","_c","offset","_d","height","_e","symbol","_f","symbolColor","_g","animationDuration","_h","animationDelay","_j","animationThreshold","useRef","_k","useState","isCollapsed","setIsCollapsed","isServer","setIsServer","useEffect","useIsServer","options","intersectionObserverEntry","setIntersectionObserverEntry","current","IntersectionObserver","observer_1","entries","observe","disconnect","threshold","root","rootMargin","useIntersection","isIntersecting","timer_1","setTimeout","clearTimeout","getSkillBarColor","useCallback","skill","color","bar","getTitleColor","entry","title","_jsx","children","map","_jsxs","className","lineHeight","background","width","transition"],"mappings":"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"}